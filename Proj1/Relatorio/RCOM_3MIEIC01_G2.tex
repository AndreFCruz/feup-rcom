\documentclass[a4paper, 11pt]{article}
\usepackage[margin=1.1in]{geometry}

%use the english line for english reports
%usepackage[english]{babel}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{orange}{rgb}{1,0.54,0}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{orange},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\setlength{\textwidth}{16cm}
\setlength{\textheight}{22cm}

\title{\Huge\textbf{1º Trabalho Laboratorial:}\linebreak\linebreak
\Huge\textbf{Ligação de Dados}\linebreak\linebreak\linebreak
\Large\textbf{Relatório}\linebreak\linebreak
\linebreak\linebreak
\includegraphics[scale=0.1]{images/feup-logo.png}\linebreak\linebreak
\linebreak
\Large{Mestrado Integrado em Engenharia Informática e Computação} \linebreak\linebreak
\Large{Redes de Computadores}\linebreak
}

\author{\textbf{Turma 1 Grupo 2:}\\
\linebreak\\
André Cruz - 201503776 \\
Bruno Piedade - 201505668 \\
Edgar Carneiro - 201503748 \\
\linebreak\linebreak \\
 \\ Faculdade de Engenharia da Universidade do Porto \\ Rua Roberto Frias, s\/n, 4200-465 Porto, Portugal \linebreak\linebreak
\linebreak\linebreak\vspace{1cm}}

\maketitle
\thispagestyle{empty}

%************************************************************************************************
%************************************************************************************************

\newpage

%Todas as figuras devem ser referidas no texto. %\ref{fig:codigoFigura}
%
%%Exemplo de código para inserção de figuras
%%\begin{figure}[h!]
%%\begin{center}
%%escolher entre uma das seguintes três linhas:
%%\includegraphics[height=20cm,width=15cm]{path relativo da imagem}
%%\includegraphics[scale=0.5]{path relativo da imagem}
%%\includegraphics{path relativo da imagem}
%%\caption{legenda da figura}
%%\label{fig:codigoFigura}
%%\end{center}
%%\end{figure}
%
%
%\textit{Para escrever em itálico}
%\textbf{Para escrever em negrito}
%Para escrever em letra normal
%``Para escrever texto entre aspas''
%
%Para fazer parágrafo, deixar uma linha em branco.
%
%Como fazer bullet points:
%\begin{itemize}
	%\item Item1
	%\item Item2
%\end{itemize}
%
%Como enumerar itens:
%\begin{enumerate}
	%\item Item 1
	%\item Item 2
%\end{enumerate}
%
%\begin{quote}``Isto é uma citação''\end{quote}

\tableofcontents

\newpage

%Sumário
\section{Sumário}
\normalsize 

Pimeiro parágrafo sobre o contexto do trabalho:\\
Segundo parágrafo sobre as principais conclusões do relatório.\\
TODO

%1.Introdução
\section{Introdução}

O trabalho, realizado no âmbito da cadeira de Redes de Computadores, tinha como objetivo a implementação de um protocolo de ligação de dados, de acordo como uma especificação fornecida, através de um guião. Era também pedido aos alunos que desenvolvessem um simples aplicação, de forma a testar o protocolo implementado.

O Relatório encontra-se dividido em diversas secções, nas quais se pode encontrar a seguinte informação:
\begin{itemize}
	\item \textbf{Arquitetura}, onde são descriminados os diferentes blocos funcionais e interfaces.
	\item \textbf{Estrutura do código}, apresentando as API's, principais estruturas de dados, principais funções e a sua realação com a arquitetura.
	\item \textbf{Casos de uso principais}, onde são identificados os principais casos de uso e as suas sequências de chamada de funções.
	\item \textbf{Protocolo de ligação lógica}, identificando os principais aspetos funcionais, bem como a descrição da estratégia de implementação.
	\item \textbf{Protocolo de aplicação},  identificando os principais aspetos funcionais, bem como a descrição da estratégia de implementação.
	\item \textbf{Validação}, descrevendo os testes efetuados.
	\item \textbf{Eficiência do protocolo de ligação de dados}, onde é realizada a caracterização estatística da eficiência do protocolo implementado.
	\item \textbf{Conclusões}, onde é feita uma tese da informação apresentada nas secções anteriores, bem como uma reflexão sobre os objectivos de aprendizagem alcançados.
\end{itemize}

%2.Arquitetura
\section{Arquitetura}

\large\textbf{Blocos Funcionais}\\
\normalsize 

No Trabalho é possível distinguir a existência de duas camadas bem definidas:  a camada do protocolo de ligação de dados - \textit{LinkLayer} - e a camada da aplicação - \textit{AplicationLayer}.
Os ficheiros \textit{LinkLayer.h} e  \textit{LinkLayer.c} representam a camada de ligação de dados. Os ficheiros \textit{AplicationLayer.h, AplicationLayer.c, Packets.h} e \\texit{ Packets.c} representam a camada da aplicação.

A camada de ligação de dados é a camada responsável pelo estabelecimento de ligação e, portanto, tem todas as funções que asseguram a consistência do protocolo, como o tratamento de erros, envio de mensagens de comunicação, entre outros. É também nesta camada que a interação com a porta série é feita, nomeadamente, a sua abertura, a escrita e leitura desta e o seu fecho.

A camada da aplicação é responsável pela envio e receção de ficheiros, segmentando o ficheiro a enviar em tramas de tamanho definivel pelo utilizador. Esta camada faz uso da inteface da camada de ligação de dados, chamando as suas funções para o envio e receção de segmentos do ficheiro a receber / enviar. A camada da aplicação é sub-dividida em duas sub-camadas, dai o uso dos ficheiros \textit{AplicationLayer.h} e \textit{AplicationLayer.c} para representar a camada mais abstrata, responsável pelo envio do fiicheiro e a receção do ficheiro, e que faz uso da camada menos abstrata, representada nos fiheiros  \textit{Packets.h} e \textit{Packets.c}, que é responsável pela segmentação do ficheiro em pacotes e envio de pacotes de controlo e informação.\\

\large\textbf{Interface}\\
\normalsize

Na interface da linha de comandos é permitido ao utilizador correr o programa usando o mesmo binário, independentemente de ser o recetor ou o emissor.
É necessário o utilizador especificar se será o emissor / recetor, qual o Serial Port a ser usado e, no caso do recetor, qual o ficheiro a transmitir. No entanto, existem parâmetros opcionais que permitem definir outras definições relcionadas com a transmissão de informação, tais como: \textit{baudrate}, tamanho dos segmentos de informação, número de tentativas no reenvio de tramas e tempo esperado até ao reenvio de uma trama.
Assim, a aplicação pode correr com valores inseridos pelo utilizador, ou com os seus valores por defeito.

%3.Estrutura do código
\section{Estrutura do Código}

\large\textbf{\textit{Application Layer}}\\
\normalsize

Os ficheiros \textit{AplicationLayer.h} e \textit{AplicationLayer.c} , representantes da sub-camada mais abstrata da camada da aplicação, fazem uso de uma estrutura de dados que guarda o descritor do ficheiro da porta série, o nome do ficheiro a ser transmitido, o tamanho máximo de mensagem a ser transmitido e ainda o tipo de conexão a ser usado - emissor ou recetor.

\begin{lstlisting}[language=C]
typedef struct {
    int fd; // serial port's file descriptor
    char * fileName;
    ConnectionType type;
    int maxDataMsgSize;
} ApplicationLayer;
\end{lstlisting}

As prinicpais funções desta sub-camada são:

\begin{lstlisting}[language=C]
int initApplicationLayer(const char * port, int baudrate, int timeout, int numRetries, ConnectionType type, int maxDataMsgSize, char * file);
void destroyApplicationLayer();
int sendFile();
int receiveFile();
\end{lstlisting}

Os ficheiros \textit{Packets.h} e \textit{Packets.c} , representantes da sub-camada menos abstrata da camada da aplicação, fazem uso de três estruturas de dados: a estrutura \textit{Packet} que guarda um apontador para a informação, e o tamanho dessa informação; a estrutura \textit{DataPacket]} que guarda o número sequencial do pacote a ser enviado, o seu tamanho e o apontador para essa informação; a estrutura \textit{ControlPacket} que guarda o tipo de pacote de Controlo - inicio ou fim -, o nome do ficheiro, o tamanho do ficheiro e o número de argumentos do pacote de controlo.

\noindent\begin{minipage}{.22\textwidth}
\begin{lstlisting}[frame=tlrb]
typedef struct {
    uchar * data;
    uint size;
} Packet;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.22\textwidth}
\begin{lstlisting}[frame=tlrb]
typedef struct {
    uchar seqNr;
    uint size;
    uchar * data;
} DataPacket;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[frame=tlrb]
typedef struct {
    PacketType type;
    char fileName[MAX_FILE_NAME];
    uint fileSize;
    uint argNr;
} ControlPacket;
\end{lstlisting}
\end{minipage}

As principais funções desta sub-camada são:

\begin{lstlisting}[language=C]
int sendDataPacket(int fd, DataPacket * src);
int sendControlPacket(int fd, ControlPacket * src);
int receiveDataPacket(int fd, DataPacket * dest);
int receiveControlPacket(int fd, ControlPacket * dest);
\end{lstlisting}

\large\textbf{\textit{Link Layer}}\\
\normalsize

A camada da ligação de dados é representada através de uma estrutura de dados onde é guardado a porta série utilizada, o \textit{baudrate} utilizado, o número de sequência da trama esperada, tempo esperado até ao reenvio de uma trama, e o número de tentativas de reenvio de uma trama.

\begin{lstlisting}[language=C]
typedef struct {
	char port[MAX_PORT_NAME];
	int baudRate;
	uint seqNumber;
	uint timeout;
	uint numRetries;
} LinkLayer;
\end{lstlisting}

As principais funções desta camada são:

\begin{lstlisting}[language=C]
int initLinkLayer(int porta, int baudRate, uint timeout, uint numTransmissions);
int openSerialPort();
int llopen(ConnectionType type);
int llclose(int fd);
int llwrite(int fd, uchar ** buffer, int length);
int llread(int fd, uchar ** buffer);
\end{lstlisting}

%4. Casos de uso principais
\section{Casos de uso principais}

Existem dois casos de uso principais bem distintos: correr o programa como emissor ou correr o prorama como recetor. Em cada um destes casos é possível correr o programa usando o mesmo binário, apenas dependendo os argumentos usados na chamada do programa, sendo estes:

\begin{lstlisting}[language=C]
	printf("Usage:\t%s <SerialPort> <r/w> <FILE_NAME> [BAUDRATE] [DATA_BYTES] [NUM_RETRIES] [TIMEOUT]\n", progName);
	printf("Arguments between [ ] are optional\n");
\end{lstlisting}

No caso em que o programa é executado como \textbf{recetor} a sequência de chamada de funções, considerando as de maior relevência, é:
\begin{itemize}
	\item \textbf{receiveFile}, que tem como objetivo receber o ficheiro indicado e que faz uso de funções como a \textbf{receiveControlPacket}, \textbf{receiveDataPacket}, \textbf{llopen} e \textbf{llclose}.
	\item \textbf{receiveControlPacket}, que tem como objetivo enviar um pacote de controlo, do tipo \textit{START} no início da transmissão e do tipo \textit{END} no fim da transmissão, e que faz uso de funções como \textbf{fillControlPacketArg} e \textbf{llread}.
	\item \textbf{receiveDataPacket},  que tem como objeitvo enviar um pacote de informação,e que faz uso de funções como \textbf{llread}.
	\item \textbf{fillControlPacketArg}, que tem como objetivo preencher os argumentos de um control packet, com informação recebida.
	\item \textbf{llread}, que tem como objetivo ler da Porta Série informação, aplicando-lhe \textit{Byte Destuffing} e \textit{Deframing}. Faz uso das funções \textbf{byteDestuffing, deframingInformation, sendControlFrame} e \textbf{read}.
\end{itemize}

No caso em que o programa é executado como \textbf{emissor} a sequência de chamada de funções, considerando as de mairo relevância, é:
\begin{itemize}
	\item \textbf{sendFile}, que tem como objetivo enviar o ficheiro indicado e que faz uso de funções como a \textbf{sendControlPacket}, \textbf{sendDataPacket}, \textbf{llopen} e \textbf{llclose}.
	\item \textbf{sendControlPacket}, que tem como objetivo enviar um pacote de controlo, do tipo \textit{START} no início da transmissão e do tipo \textit{END} no fim da transmissão, e que faz uso de funções como \textbf{makeControlPacket} e \textbf{llwrite}.
	\item \textbf{sendDataPacket},  que tem como objeitvo enviar um pacote de informação, e que faz uso de funções como \textbf{makeDataPacket} e \textbf{llwrite}.
	\item \textbf{makeControlPacket}, que tem como objetivo criar uma pacote de controlo.
	\item \textbf{makeDataPacket}, que tem como objetivo criar um pacot de informação.
	\item \textbf{llwrite}, que tem como objetivo escrever para a Porta Série a informação recebida como argumento, após aplicar uma \textit{frame} e \textit{Byte Stuffing} à informação. Faz uso das funções \textbf{framingInformation, byteStuffing, readControlFrame} e \textbf{write}.
\end{itemize}

As funções de mais baixo nível, associadas à camada da ligação de dados, são usadas quer pelo emissor quer pelo recetor, sendo estas:
\begin{itemize}
	\item \textbf{llopen}, que tem como objetivo abrir a ligação da Porta Série. Faz uso das funções \textbf{openSerialPort, sendControlFrame} e \textbf{readControlFrame}.
	\item \textbf{llclose}, que tem como objetivo terminar a ligação da Porta Série. Faz uso das funções \textbf{llcloseTransmitter, llcloseReceiver} - conforme seja Emissor ou Recetor - e \textbf{close}.
	\item \textbf{sendControlFrame}, que tem como objetivo enviar uma trama de controlo. Faz uso das funções \textbf{createControlFrame} e \textbf{write}.
	\item \textbf{readControlFrame}, que tem como objetivo receber uma trama de controlo. Faz uso da função \textbf{readFromSerialPort}.
\end{itemize}

%5. Protocolo de ligação lógica
\section{Protocolo de ligação lógica}

 A camada de ligação de dados é a camada de mais baixo nível e é a camada responsável pela interação direta com a Porta Série. Algumas das funcionalidades implementada por esta camada são: abertura e fecho da Porta Série; escrita de um tramas de informação e controlo; leitura de um tramas de informação e controlo; criação de tramas de controle; \textit{byte stuffing} e \textit{byte destuffing} de uma trama; \textit{framing } e \textit{deframing} de uma trama.

A nível da API da camada de ligação de dados foram implementadas as quatro funções previstas: \textbf{llopen, llclose, llread} e \textbf{llwrite}.\\

A função \textbf{llopen} é responsável por estabelecer a ligação através da Porta Série. Faz recurso à função \textbf{openSerialPort} que abre a Porta Série e configura uma nova \textit{struct termios}. De seguida, e segundo o protocolo especificado no guião, envia uma trama de controlo do tipo SET e espera pela receção de uma trama de controlo do tipo UA, no caso do emissor, e faz o processo oposto no caso do recetor - espera pela receção de uma trama de controlo do tipo SET e após a sua receção envia uma trama de controlo do tipo UA.

A função \textbf{llclose} é responsável pelo término da ligação estabelecida através da Porta Série. Segundo o protocolo especificado no guião, o término da ligação é realizado através do envio de uma trama de controlo do tipo DISC por parte do emissor,  recessão do DISC por parte do recetor, envio de uma trama também do tipo DISC por parte do recetor, receção do DISC enviado pelo recetor, envio de uma trama de controlo do tipo UA por parte do emissor, receção do UA por parte do recetor. Após a verificação deste protocolo de terminação, é reposta a \textit{struct termios} anterior à configurada pela função \textit{llopen} e fecha-se a ligação usando o descritor de ficheiro da Porta Série.

A função \textbf{llread} é responsável pela leitura de informação da Porta Série, sendo que irá aplicar \textit{destufffing} e \textit{deframing} à trama recebida. Se ocorrer um erro no \textit{destuffing} ou um erro na \textit{frame} que não seja no \textit{BCC2} a trama é descartada, ficando assim à espera de uma nova trama. Se houver um error, e for no \textit{BCC2}, a trama é descartada, o recetor continua a espera de uma nova trama, mas envia um rama de controle do tipo REJ. Se a trama for corretamente recebida, esta é retornada e o recetor envia uma trama de controle do tipo RR.

A função \textbf{llwrite} é responsável pelo envio de informação através da Porta Série. Esta recebe a mensagem a enviar da camada superior e aplica-lhe \textit{framing} e \textit{stuffing}.
De seguida, tenta escrever a trama, sendo que se não receber uma resposta do tipo RR durante um intervalo de tempo previamente definido - \textit{default} é 3 segundos - este reenvia a trama. O reenvio da trama é feito um número de vezes previamente definido - \textit{default} é 3 tentativas. Se ao fim desse número de tentativas não tiver obtido sucesso, retorna erro.\\

\textbf{Consultar \underline{Anexo II} para extratos de código.}

%6. Protocolo de aplicação
\section{Protocolo de aplicação}

A camada de aplicação é a camada de alto nível responsável pelo processo de envio e receção do ficheiro fonte fazendo uso do API disponibilizado pela camada ligação de dados. As funcionalidades implementadas por esta camada são: inicializar a ligação; ler o ficheiro fonte e dividi-lo em pacotes de dados (caso seja emissor); reconstruir o ficheiro fonte a partir de pacotes de dados (caso seja recetor); receber e enviar os pacotes; terminar a ligação.\\

Para gerir a interação com os pacotes de dados foi desenvolvido o API (Packet.c) composto pelas seguintes funções:

Em relação aos pacotes de dados: 
A função \textbf{makeDataPacket} que cria o pacote de dados a partir da informação original do ficheiro fonte; \textbf{sendDataPacket} que envia o pacote de dados utilizando llwrite; \textbf{receiveDataPacket} que recebe o pacote de dados utilizando llread e recolhe a informação do ficheiro fonte.

Em relação aos pacote de controlo:
A função \textbf{makeControlPacket} que cria o pacote de controlo; \textbf{sendControlPacket} que envia o pacote de controlo utilizando \textit{llwrite}; \textbf{receiveControlPacket} que recebe o pacote utilizando \textit{llread}.\\

Foram implementadas as seguintes funções:
\begin{itemize}
	\item A função \textbf{sendFile} (utilizado no caso do emissor) é responsável por inicializar a ligação, ler o ficheiro fonte e dividi-lo em pacotes de dados, enviar os mesmos e terminar a ligação. Faz recurso a 3 funções do API da camada de ligação de dados: \textit{llopen, llwrite} e \textit{llclose} e API de pacotes.
	\item A função \textbf{receiveFile} (utilizado no caso do recetor) é responsável por inicializar a ligação, ler os pacotes de dados, reconstruir o ficheiro fonte utilizando os mesmos e terminar a ligação. Faz recurso a 3 funções do API da camada de ligação de dados: \textit{llopen, llread} e \textit{llclose} e API de pacotes.
\end{itemize}

\textbf{Consultar \underline{Anexo III} para extratos de código.}

%7. Validação
\section{Validação}

Para validação do programa desenvolvido, e para garantir que funcionava de acordo com o protocolo especificado, foram realizados constantemente testes durante o desenvolvimento do programa e também na sua demonstração. Foram testados ficheiros de diferentes tamanhos e enviados com diferentes baudrates e diferentes tamanhos de pacotes de informação. Foram realizados, simultaneamente com os testes já referidos, testes de interrupção da comunicação na Porta Série e testes de introdução de erros através do curto-circuito existente nas portas séries. Todos testes terão sido também realizados na presença do professor, aquando do momento de avaliação.

%8. Eficiência do protocolo de ligação de dados
\section{Eficiência do protocolo de ligação de dados}

(caraterização estatística da  eficiência do protocolo, feita com recurso a medidas sobre o código desenvolvido. A caracterização teórica de um protocolo Stop\&Wait, que deverá ser usada como termo de comparação, encontra-se descrita nos slides de Ligação Lógica das aulas teóricas). \\

\textbf{Variável: Tamanho da trama I}\\
Usando um \textit{baudrate} constante de 115200 e uma imagem de tamanho constante 80942 \textit{bytes}, fazendo variar o tamanho da trama I, obteve-se:\\


\textbf{Variável: Capacidade da ligação}\\
Usando uma imagem de tamanho constante 80942 \textit{bytes} e um tamanho de trama I constante de valor 256, fazendo variar o \textit{baudrate}, obteve-se:\\

\textbf{Variável: Tempo de Propagação}\\
Usando uma imagem de tamanho constante 80942 \textit{bytes}, um tamanho de trama I constante de valor 256 e um \textit{baudrate} constante de 460800 , fazendo variar o tempo de processamento de cada trama recebida, obteve-se:\\

\textbf{Variável: \textit{Frame Error Ratio}}\\
Usando uma imagem de tamanho constante 80942 \textit{bytes}, um tamanho de trama I constante de valor 256 e um \textit{baudrate} constante de 460800, fazendo variar a probabilidade de ocurrencia de erros no cabeçalho das tramas I , obteve-se:\\

\newpage

%9. Conclusões
\section{Conclusões}

  (síntese da informação apresentada nas secções anteriores; reflexão sobre os objectivos de aprendizagem alcançados)
\newpage

%Anexo I
\section{Anexo I}
\begin{lstlisting}[language=C]


\end{lstlisting}

\newpage

%Anexo2
\section{Anexo II}

\begin{lstlisting}[caption = llopen, language=C]
int llopen(ConnectionType type) {
	connectionType = type;

	int fd = openSerialPort();

	switch (type) {
	case TRANSMITTER:
		if ((sendControlFrame(fd, SET) > 0) && (readControlFrame(fd, UA) == OK))
			return fd;
		break;
	case RECEIVER:
		if ((readControlFrame(fd, SET) == OK) && (sendControlFrame(fd, UA) > 0))
			return fd;
		break;
	}

	logError("Failed llopen");
	return -1;
}
\end{lstlisting}


\begin{lstlisting}[caption = llclose, language=C]
int llclose(int fd) {
	if (TRANSMITTER == connectionType)
		llcloseTransmitter(fd);
	else if (RECEIVER == connectionType)
		llcloseReceiver(fd);
	else
		logError("llclose: no connection type set");

	//Reset terminal to previous configuration
	if ( tcsetattr(fd,TCSANOW,&oldtio) == -1 ) {
		perror("tcsetattr");
		return -1;
	}

	if (close(fd) < 0) {
		perror("failed close(fd)");
		return -1;
	}
	return OK;
}
\end{lstlisting}

\begin{lstlisting}[caption = llread, language=C]
int llread(int fd, uchar ** dest) {
	int ret;
	while ( 1 ){
		if ( (ret = readFromSerialPort(fd, dest)) > 0 ) {
			if (byteDestuffing(*dest, &ret) == ERROR) {
				logError("llread: Failed byteDestuffing");
				free(*dest);
				continue;
			}

			ret = deframingInformation(dest, &ret);
			if (ret == ERROR2) {
				sendControlFrame(fd, REJ);
			}
			if (ret != OK) {
				logError("llread: Failed to deframe information");
				free(*dest);
				continue;
			}

			sendControlFrame(fd, RR);
			return ret;
		}
	}
	
	return -1;
}
\end{lstlisting}

\begin{lstlisting}[caption = llwrite, language=C]
int llwrite(int fd, uchar ** bufferPtr, int length) {
	int res = 0;

	if (framingInformation(bufferPtr, &length) == ERROR) {
		logError("llwrite: Failed to create Information Frame");
		return -1;
	}

	if (byteStuffing(bufferPtr, &length) == ERROR) {
		logError("llwrite: Failed to create Information Frame");
		return -1;
	}

	uint tries = 0;
	setAlarm();
	do {
		alarmWentOff = FALSE;
		if ((res = write(fd, *bufferPtr, length)) < length) {
			logError("llwrite error: * Bad write *");
			continue;
		}

		alarm(ll->timeout);
	} while ( (readControlFrame(fd, RR) != OK) && (++tries < (ll->numRetries)));

	stopAlarm();

	if (tries >= ll->numRetries)
		return ERROR;
		
	return res;
}
\end{lstlisting}

\newpage

%Anexo3
\section{Anexo III}

\begin{lstlisting}[caption = sendFile, language=C]
int sendFile() {
	if (al == NULL)
		return logError("AL not initialized");

	FILE * file = fopen(al->fileName, "r");
	if (file == NULL)
		return logError("Error while opening file");

	// establish connection
	al->fd = llopen(al->type);
	if (al->fd < 0)
		return logError("Failed llopen");

	ControlPacket ctrlPacket;
	ctrlPacket.type = START;
	strcpy(ctrlPacket.fileName, al->fileName);
	ctrlPacket.fileSize = getFileSize(file);
	ctrlPacket.argNr = CTRL_PACKET_ARGS;

	if (sendControlPacket(al->fd, &ctrlPacket) != OK)
		return logError("Error sending control packet");

	DataPacket dataPacket;
	uchar * fileBuffer = (uchar *) malloc(al->maxDataMsgSize * sizeof(char));
	uint res, progress = 0, currentSeqNr = 0;
	int state = OK;
	printProgressBar(0, ctrlPacket.fileSize);
	
	while ( (res = fread(fileBuffer, sizeof(char), al->maxDataMsgSize, file)) > 0 ) {
		dataPacket.seqNr = currentSeqNr;
		currentSeqNr = (currentSeqNr + 1) % 256;
		dataPacket.size = res;
		dataPacket.data = fileBuffer;
		if (sendDataPacket(al->fd, &dataPacket) != OK) {
			state = logError("Error sending data packet");
			break;
		}

		progress += res;
		printProgressBar(progress, ctrlPacket.fileSize);
	}
	free(fileBuffer);

	if (fclose(file)) {
		perror("Error while closing file");
		return ERROR;
	}

	ctrlPacket.type = END;
	if ((state == OK) && sendControlPacket(al->fd, &ctrlPacket) != OK)
		return logError("Error sending control packet");

	if (state != OK || llclose(al->fd) != OK)
		return ERROR;

	printf("\nFile sent successfully.\n");

	return OK;
}
\end{lstlisting}


\begin{lstlisting}[caption = receiveFile, language=C]
int receiveFile() {
	if (al == NULL)
		return logError("AL not initialized");

	al->fd = llopen(al->type);
	if (al->fd < 0)
		return logError("Failed llopen");

	ControlPacket ctrlPacket;
	if (receiveControlPacket(al->fd, &ctrlPacket) != OK || ctrlPacket.type != START) {
		return logError("Error receiving control packet");
	}

	if (al->fileName == NULL) {
		al->fileName = malloc(sizeof(char) * MAX_FILE_NAME);
		strncpy(al->fileName, ctrlPacket.fileName, MAX_FILE_NAME);
	}

	FILE * outputFile = fopen(al->fileName, "wb");
	if (outputFile == NULL)
		return logError("Could not create output file");

	printf("Created file %s with expected size %d.\n", al->fileName, ctrlPacket.fileSize);

	DataPacket dataPacket;
	uint progress = 0, currentSeqNr = 0;
	int state = OK;
	printProgressBar(0, ctrlPacket.fileSize);

	while (progress < ctrlPacket.fileSize) {
		if ( (state = receiveDataPacket(al->fd, &dataPacket)) != OK) {
			logError("Error receiving data packet");
			break;
		}

		if (dataPacket.seqNr < currentSeqNr) {
			printf("\tReceived duplicate packet: %d. Current: %d\n", dataPacket.seqNr, currentSeqNr);
			continue;
		}
		currentSeqNr = (currentSeqNr + 1) % 256;
		progress += (uint) dataPacket.size;

		printProgressBar(progress, ctrlPacket.fileSize);

		if (fwrite(dataPacket.data, sizeof(char), dataPacket.size, outputFile) == 0) {
			return logError("sendFile: fwrite returned 0");
		}

		free(dataPacket.data);
	}

	if (fclose(outputFile)) {
		perror("fclose failed");
		return ERROR;
	}

	if ((state == OK) && (receiveControlPacket(al->fd, &ctrlPacket) != OK || ctrlPacket.type != END)) {
		return logError("Error receiving control packet");
	}

	if (state != OK || llclose(al->fd) != OK)
		return logError("llclose failed");

	printf("\nFile received successfully.\n");

	return OK;
}
\end{lstlisting}

\begin{lstlisting}[caption = makeDataPacket, language=C]
void makeDataPacket(DataPacket * src, Packet * dest) {
	int packetSize = HEADER_SIZE + (src->size);
	uchar * data = (uchar *) malloc(packetSize);

	data[CTRL_FIELD_IDX] = DATA;
	data[SEQ_NUM_IDX] = src->seqNr;
	data[DATA_PACKET_SIZE2_IDX] = (uchar) (src->size / SIZE2_MUL);
	data[DATA_PACKET_SIZE1_IDX] = (uchar) (src->size % SIZE2_MUL);

	memcpy(&data[HEADER_SIZE], src->data, src->size);

	dest->data = data;
	dest->size = packetSize;
}
\end{lstlisting}

\begin{lstlisting}[caption = makeControlPacket, language=C]
void makeControlPacket(ControlPacket * src, Packet * dest) {
	int fileNameSize = strnlen(src->fileName, MAX_FILE_NAME);
	int packetSize = 1 + 2 * (src->argNr) + fileNameSize + FILE_SIZE_LENGTH;

	uchar * data = (uchar *) malloc(packetSize);

	data[CTRL_FIELD_IDX] = src->type;

	int index = 1;
	data[index++] = FILE_SIZE_ARG;
	data[index++] = sizeof(int);

	uchar fileSize[sizeof(int)];
	convertIntToBytes(fileSize, src->fileSize);
	memcpy(&data[index], fileSize, FILE_SIZE_LENGTH);

	index += FILE_SIZE_LENGTH;

	data[index++] = FILE_NAME_ARG;
	data[index++] = (uchar) fileNameSize;
	memcpy(&data[index], src->fileName, fileNameSize);

	dest->data = data;
	dest->size = packetSize;
}
\end{lstlisting}

\end{document}
